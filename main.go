package main

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"strconv"
	"strings"
	"sync"
	"time"
)

type AudioTrack struct {
	ID       string `json:"id"`
	Title    string `json:"title"`
	Artist   string `json:"artist"`
	Duration int    `json:"duration"` // in seconds
}

type StreamingServer struct {
	audioDir     string
	uploadDir    string
	tracks       map[string]*AudioTrack
	segmentCache map[string][]byte
	rateLimiter  map[string]time.Time
	mu           sync.RWMutex
}

func NewStreamingServer(audioDir, uploadDir string) *StreamingServer {
	return &StreamingServer{
		audioDir:     audioDir,
		uploadDir:    uploadDir,
		tracks:       make(map[string]*AudioTrack),
		segmentCache: make(map[string][]byte),
		rateLimiter:  make(map[string]time.Time),
	}
}

func (s *StreamingServer) loadTracks() {
	// Load existing tracks from audio directory
	if _, err := os.Stat(s.audioDir); os.IsNotExist(err) {
		return
	}

	entries, err := os.ReadDir(s.audioDir)
	if err != nil {
		log.Printf("Error reading audio directory: %v", err)
		return
	}

	for _, entry := range entries {
		if entry.IsDir() {
			trackID := entry.Name()
			// Try to load track metadata (you might want to store this in a JSON file)
			masterPlaylistPath := filepath.Join(s.audioDir, trackID, "playlist.m3u8")
			if _, err := os.Stat(masterPlaylistPath); err == nil {
				// Get duration from any of the segment playlists
				duration := s.getTrackDurationFromPlaylist(trackID)
				s.tracks[trackID] = &AudioTrack{
					ID:       trackID,
					Title:    strings.ReplaceAll(trackID, "_", " "),
					Artist:   "Unknown Artist",
					Duration: duration,
				}
				log.Printf("Loaded existing track: %s", trackID)
			}
		}
	}
}

func (s *StreamingServer) getTrackDurationFromPlaylist(trackID string) int {
	playlistPath := filepath.Join(s.audioDir, trackID, "med", "playlist.m3u8")
	data, err := os.ReadFile(playlistPath)
	if err != nil {
		return 180 // Default 3 minutes
	}

	lines := strings.Split(string(data), "\n")
	duration := 0.0
	for _, line := range lines {
		if strings.HasPrefix(line, "#EXTINF:") {
			var segDuration float64
			fmt.Sscanf(line, "#EXTINF:%f,", &segDuration)
			duration += segDuration
		}
	}
	return int(duration)
}

func (s *StreamingServer) generateMasterPlaylist(trackID string) string {
	basePath := fmt.Sprintf("/stream/%s", trackID)
    return fmt.Sprintf(`#EXTM3U
#EXT-X-VERSION:3

#EXT-X-STREAM-INF:BANDWIDTH=40000,CODECS="mp4a.40.2"
%s/low/playlist.m3u8

#EXT-X-STREAM-INF:BANDWIDTH=80000,CODECS="mp4a.40.2"
%s/med/playlist.m3u8

#EXT-X-STREAM-INF:BANDWIDTH=120000,CODECS="mp4a.40.2"
%s/high/playlist.m3u8
`, basePath, basePath, basePath)
}

func (s *StreamingServer) handleMasterPlaylist(w http.ResponseWriter, r *http.Request) {
	trackID := strings.TrimPrefix(r.URL.Path, "/stream/")
	trackID = strings.TrimSuffix(trackID, "/playlist.m3u8")

	s.mu.RLock()
	track, exists := s.tracks[trackID]
	s.mu.RUnlock()

	if !exists {
		http.Error(w, "Track not found", http.StatusNotFound)
		return
	}

	// Set proper headers for M3U8
	w.Header().Set("Content-Type", "application/vnd.apple.mpegurl")
	w.Header().Set("Access-Control-Allow-Origin", "*")
	w.Header().Set("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
	w.Header().Set("Access-Control-Allow-Headers", "Content-Type")
	w.Header().Set("Cache-Control", "no-cache")

	// Check if master playlist file exists, if not generate it
	masterPlaylistPath := filepath.Join(s.audioDir, trackID, "playlist.m3u8")
	if data, err := os.ReadFile(masterPlaylistPath); err == nil {
		w.Write(data)
	} else {
		// Generate and serve master playlist
		playlist := s.generateMasterPlaylist(trackID)
		w.Write([]byte(playlist))
	}

	log.Printf("Served master playlist for track: %s (%s)", track.Title, trackID)
}

func (s *StreamingServer) handleQualityPlaylist(w http.ResponseWriter, r *http.Request) {
	parts := strings.Split(strings.Trim(r.URL.Path, "/"), "/")
	if len(parts) < 4 {
		http.Error(w, "Invalid path", http.StatusBadRequest)
		return
	}

	trackID := parts[1]
	quality := parts[2]

	s.mu.RLock()
	track, exists := s.tracks[trackID]
	s.mu.RUnlock()

	if !exists {
		http.Error(w, "Track not found", http.StatusNotFound)
		return
	}

	// Serve the actual playlist file generated by FFmpeg
	playlistPath := filepath.Join(s.audioDir, trackID, quality, "playlist.m3u8")
	
	data, err := os.ReadFile(playlistPath)
	if err != nil {
		http.Error(w, "Playlist not found", http.StatusNotFound)
		return
	}

	w.Header().Set("Content-Type", "application/vnd.apple.mpegurl")
	w.Header().Set("Access-Control-Allow-Origin", "*")
	w.Header().Set("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
	w.Header().Set("Access-Control-Allow-Headers", "Content-Type")
	w.Header().Set("Cache-Control", "no-cache")

	w.Write(data)
	log.Printf("Served %s quality playlist for: %s", quality, track.Title)
}

func (s *StreamingServer) handleSegment(w http.ResponseWriter, r *http.Request) {
	// Rate limiting
	clientIP := r.RemoteAddr
	s.mu.Lock()
	if lastRequest, exists := s.rateLimiter[clientIP]; exists {
		if time.Since(lastRequest) < 50*time.Millisecond {
			s.mu.Unlock()
			http.Error(w, "Rate limited", http.StatusTooManyRequests)
			return
		}
	}
	s.rateLimiter[clientIP] = time.Now()
	s.mu.Unlock()

	parts := strings.Split(strings.Trim(r.URL.Path, "/"), "/")
	if len(parts) < 4 {
		http.Error(w, "Invalid segment path", http.StatusBadRequest)
		return
	}

	trackID := parts[1]
	quality := parts[2]
	segmentFile := parts[3]

	cacheKey := fmt.Sprintf("%s/%s/%s", trackID, quality, segmentFile)

	// Check cache
	s.mu.RLock()
	if cachedData, exists := s.segmentCache[cacheKey]; exists {
		s.mu.RUnlock()
		
		w.Header().Set("Content-Type", "video/MP2T")
		w.Header().Set("Access-Control-Allow-Origin", "*")
		w.Header().Set("Cache-Control", "max-age=86400")
		w.Header().Set("Accept-Ranges", "bytes")
		w.Header().Set("Content-Length", strconv.Itoa(len(cachedData)))
		
		w.Write(cachedData)
		return
	}
	s.mu.RUnlock()

	// Load from file
	filePath := filepath.Join(s.audioDir, trackID, quality, segmentFile)
	data, err := os.ReadFile(filePath)
	if err != nil {
		http.Error(w, "Segment not found", http.StatusNotFound)
		return
	}

	// Cache the segment
	s.mu.Lock()
	if len(s.segmentCache) < 1000 {
		s.segmentCache[cacheKey] = data
	}
	s.mu.Unlock()

	w.Header().Set("Content-Type", "video/MP2T")  // Changed from audio/webm
	w.Header().Set("Access-Control-Allow-Origin", "*")
	w.Header().Set("Cache-Control", "max-age=86400")
	w.Header().Set("Accept-Ranges", "bytes")
	w.Header().Set("Content-Length", strconv.Itoa(len(data)))

	w.Write(data)
}

func (s *StreamingServer) handleTrackList(w http.ResponseWriter, r *http.Request) {
	s.mu.RLock()
	var tracks []*AudioTrack
	for _, track := range s.tracks {
		tracks = append(tracks, track)
	}
	s.mu.RUnlock()

	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Access-Control-Allow-Origin", "*")
	json.NewEncoder(w).Encode(tracks)
}

func (s *StreamingServer) handleUpload(w http.ResponseWriter, r *http.Request) {
	if r.Method != "POST" {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	err := r.ParseMultipartForm(50 << 20) // 50MB
	if err != nil {
		http.Error(w, "Error parsing form", http.StatusBadRequest)
		return
	}

	file, header, err := r.FormFile("audio")
	if err != nil {
		http.Error(w, "Error getting file", http.StatusBadRequest)
		return
	}
	defer file.Close()

	trackID := r.FormValue("trackId")
	title := r.FormValue("title")
	artist := r.FormValue("artist")

	if trackID == "" {
		trackID = fmt.Sprintf("track_%d", time.Now().Unix())
	}
	if title == "" {
		title = strings.TrimSuffix(header.Filename, filepath.Ext(header.Filename))
	}
	if artist == "" {
		artist = "Unknown Artist"
	}

	uploadPath := filepath.Join(s.uploadDir, header.Filename)
	dst, err := os.Create(uploadPath)
	if err != nil {
		http.Error(w, "Error saving file", http.StatusInternalServerError)
		return
	}
	defer dst.Close()

	_, err = io.Copy(dst, file)
	if err != nil {
		http.Error(w, "Error copying file", http.StatusInternalServerError)
		return
	}

	log.Printf("üìÅ Uploaded: %s -> %s", header.Filename, uploadPath)

	// Process audio in background
	go func() {
		err := s.processAudioFile(uploadPath, trackID, title, artist)
		if err != nil {
			log.Printf("‚ùå Error processing %s: %v", trackID, err)
		} else {
			log.Printf("‚úÖ Successfully processed: %s", trackID)
		}
	}()

	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Access-Control-Allow-Origin", "*")
	json.NewEncoder(w).Encode(map[string]interface{}{
		"success":  true,
		"trackId":  trackID,
		"message":  "Upload successful, processing audio...",
		"filename": header.Filename,
	})
}

func (s *StreamingServer) processAudioFile(inputPath, trackID, title, artist string) error {
    trackDir := filepath.Join(s.audioDir, trackID)
    os.MkdirAll(filepath.Join(trackDir, "low"), 0755)
    os.MkdirAll(filepath.Join(trackDir, "med"), 0755)
    os.MkdirAll(filepath.Join(trackDir, "high"), 0755)

    log.Printf("üéµ Processing audio: %s", inputPath)

    duration, err := s.getAudioDuration(inputPath)
    if err != nil {
        return fmt.Errorf("failed to get duration: %v", err)
    }

    // Process each quality
    qualities := []struct {
        name    string
        bitrate string
    }{
        {"low", "48k"},
        {"med", "96k"},
        {"high", "192k"},
    }

    for _, q := range qualities {
        outputDir := filepath.Join(trackDir, q.name)
        playlistPath := filepath.Join(outputDir, "playlist.m3u8")

        cmd := exec.Command("ffmpeg", "-i", inputPath,
            "-c:a", "aac",
            "-b:a", q.bitrate,
            "-f", "hls",
            "-hls_time", "10",
            "-hls_list_size", "0",
            "-hls_segment_filename", filepath.Join(outputDir, "segment_%03d.ts"),
            "-hls_playlist_type", "vod",
            "-y",
            playlistPath,
        )

        output, err := cmd.CombinedOutput()
        if err != nil {
            return fmt.Errorf("ffmpeg failed for %s quality: %v - %s", q.name, err, output)
        }

        log.Printf("‚úÖ Generated %s quality segments", q.name)
    }

    // Generate master playlist
    masterPlaylistPath := filepath.Join(trackDir, "playlist.m3u8")
    masterPlaylistContent := s.generateMasterPlaylist(trackID)
    if err := os.WriteFile(masterPlaylistPath, []byte(masterPlaylistContent), 0644); err != nil {
        return fmt.Errorf("failed to write master playlist: %v", err)
    }

    // Add track to memory
    s.mu.Lock()
    s.tracks[trackID] = &AudioTrack{
        ID:       trackID,
        Title:    title,
        Artist:   artist,
        Duration: duration,
    }
    s.mu.Unlock()

    return nil
}

func (s *StreamingServer) getAudioDuration(inputPath string) (int, error) {
	cmd := exec.Command("ffprobe", "-v", "quiet", "-show_entries",
		"format=duration", "-of", "csv=p=0", inputPath)

	output, err := cmd.Output()
	if err != nil {
		return 180, nil // Default to 3 minutes if can't detect
	}

	duration := strings.TrimSpace(string(output))
	if duration == "" {
		return 180, nil
	}

	var durationFloat float64
	fmt.Sscanf(duration, "%f", &durationFloat)
	return int(durationFloat), nil
}

func (s *StreamingServer) handleHealth(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Access-Control-Allow-Origin", "*")
	json.NewEncoder(w).Encode(map[string]string{
		"status": "healthy",
		"time":   time.Now().Format(time.RFC3339),
	})
}

// Handle CORS preflight requests
func (s *StreamingServer) handleCORS(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Access-Control-Allow-Origin", "*")
	w.Header().Set("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
	w.Header().Set("Access-Control-Allow-Headers", "Content-Type")
	w.WriteHeader(http.StatusOK)
}

func main() {
	audioDir := os.Getenv("AUDIO_DIR")
	if audioDir == "" {
		audioDir = "./processed_audio"
	}

	uploadDir := os.Getenv("UPLOAD_DIR")
	if uploadDir == "" {
		uploadDir = "./uploads"
	}

	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
	}

	// Create directories
	os.MkdirAll(audioDir, 0755)
	os.MkdirAll(uploadDir, 0755)
	os.MkdirAll("./static", 0755)

	server := NewStreamingServer(audioDir, uploadDir)
	server.loadTracks()

	// Routes
	http.HandleFunc("/stream/", func(w http.ResponseWriter, r *http.Request) {
		if r.Method == "OPTIONS" {
			server.handleCORS(w, r)
			return
		}

		path := r.URL.Path

		switch {
		case strings.HasSuffix(path, "/playlist.m3u8") && strings.Count(path, "/") == 3:
			server.handleMasterPlaylist(w, r)
		case strings.HasSuffix(path, "/playlist.m3u8"):
			server.handleQualityPlaylist(w, r)
		case strings.HasSuffix(path, ".ts"):  // Changed from .webm
			server.handleSegment(w, r)
		default:
			http.Error(w, "Invalid stream path", http.StatusBadRequest)
		}
	})

	http.HandleFunc("/api/tracks", func(w http.ResponseWriter, r *http.Request) {
		if r.Method == "OPTIONS" {
			server.handleCORS(w, r)
			return
		}
		server.handleTrackList(w, r)
	})

	http.HandleFunc("/api/upload", func(w http.ResponseWriter, r *http.Request) {
		if r.Method == "OPTIONS" {
			server.handleCORS(w, r)
			return
		}
		server.handleUpload(w, r)
	})

	http.HandleFunc("/health", server.handleHealth)

	// Serve static files (the web interface)
	http.Handle("/", http.FileServer(http.Dir("./static/")))

	log.Printf("üöÄ Starting adaptive audio streaming server on port %s", port)
	log.Printf("üìÅ Audio directory: %s", audioDir)
	log.Printf("üì§ Upload directory: %s", uploadDir)
	log.Printf("üéµ Stream URL format: http://localhost:%s/stream/TRACK_ID/playlist.m3u8", port)
	log.Printf("üì± Web interface: http://localhost:%s", port)

	log.Fatal(http.ListenAndServe(":"+port, nil))
}